
REDIS 发展历程
===
 
1. 是如何诞生的？：
    > 
    意大利的开发者被称为Antirez在2009年创建的
2. 为什么要创建?：
    > 
    Antirez在开发他的实时性的Web日志分析服务时，
   感觉到了处理大数据量的性能问题，于是他开始寻找数据存储的新方法以优化他的应用程序。
3. redis 是怎么解决网络延迟的？: 
   > 
   - 非阻塞I/O（事件驱动模型）
		> 实现代码如下：
                `fs.readFile('/file/path', (err, data) => {
					  if (err) throw err;
					  console.log(data);
					});`
                    
	- 轻量级协议(即RESP，Redis Serialization Protocol)
	- 管道化（Pipelining）
	- 复制与分片
4. redis 的轻量级协议是如何实现的？：
   >
   - 简单和直观
        >  RESP协议的语法非常简单和直观，这使得该协议很容易理解和实现。例如，一个RESP命令SET key value在Redis中被编码为：*3\r\n$3\r\nSET\r\n$3\r\nkey\r\n$5\r\nvalue\r\n。RESP命令由星号开始，后面跟着参数数量，每个参数大小以字节数表示，然后是参数内容。
   - 轻量级的数据表示 
       > 使用简单的字符串和整数来表示数据，而不是更复杂的数据类型
5. redis 管道化如何实现的?:
    > 
    - 客户端发送多个命令
    - 服务器顺序处理命令
    - 服务器一次性发送回复
      >
      Redis客户端库中，都提供了管道化的API
       > `pipe = r.pipeline()
        pipe.set('key1', 'value1')
        pipe.set('key2', 'value2')
        pipe.execute()`    
6. Redis管道化时，处理多个命令失败怎么办？
    >
    - 非事务性流水线
        > 失败不影响业务 代码实现  
         `pipe = r.pipeline()
            pipe.set('key1', 'value1')
            pipe.lpush('key1', 'value2')  #失败
            pipe.set('key3', 'value3')
            results = pipe.execute()  # 会返回 ['OK', error, 'OK']`
    - 事务性流水线
        > 失败影响业务 代码实现  
           `pipe = r.pipeline(transaction=True)
            pipe.multi()
            pipe.set('key1', 'value1')
            pipe.lpush('key1', 'value2')  # 这条会失败，因为key1存储的是字符串
            pipe.set('key3', 'value3')
            try:
                results = pipe.execute()  # 会抛出异常
            except redis.exceptions.ResponseError:
                # handle exception`
7. Jedis、Lettuce、Redisson 底层请求redis 接口的命令一样吗?
    >
     - Redisson提供了很多高层次的抽象，如分布式锁、集合数据类型等，并且底层使用了Netty进行网络通信
     - Lettuce则使用Netty构建非阻塞和支持异步、同步、和Reactive的应用
     - Jedis则是一个非常轻量级的Redis客户端，它提供了比较直接的、面向Redis原生命令的API

8. 链表多长时? redis会扩容（rehashing）
    > 扩容（动态哈希表大小调整/渐进式哈希表大小调整）：
    - 当哈希表的负载因子（即已存储节点数/哈希表大小）大于1时，Redis将开始扩容操作（哈希表分配更大的内存空间（通常是当前容量的2倍）
    > 缩容：
    - 当哈希表中的非空桶的数量小于哈希表的1/4时，Redis会进行收缩操作，减小哈希表的容量。这可以帮助降低空间浪费
    - 在Redis没有执行任务，也就是空闲时，如果负载因子小于0.1，Redis也会开始缩容操作
9. redis查询穿透的解决方式
    - 布隆过滤器（Bloom Filter）
        > 哈希key,并记录位置为1。布隆过滤器并不存储元素本身，只是存储元素的哈希位标记。例如：隆过滤器不能自动知道数据库中的更新操作，因此当数据库中的键值发生变化时，需要手动更新布隆过滤器。如果数据库中新添加了一个键值对，你需要在布隆过滤器中也添加该键。具体来说，就是把新键通过布隆过滤器的所有哈希函数计算，然后在对应的位置上将值设为1。**布隆过滤器无法从中移除某个元素，因为一个哈希位置可能对应多个元素（哈希碰撞）。如果为了删除某个元素而将某个位置从1变为0，可能会错误地表示其他元素不存在**。这就是为什么有些情况下你可能需要创建一个新的布隆过滤器来替换旧的布隆过滤器，比如当布隆过滤器的误报率增加到无法接受的程度，或者当你需要从集合中删除大量元素时。`布隆过滤器是一个概率型数据结构，它会牺牲一定的准确性以换取空间和时间效率。如果应用不能接受任何误报，那么布隆过滤器就不是一个好的选择`。
    - 缓存空对象
    - 定期更新数据
    - 预加载数据
10. Redis支持两种持久化方法：RDB 和 AOF
      - RDB持久化是将某个时间点的数据生成一个snapshot快照，并将这个snapshot存储在磁盘上。
        > 当Redis需要进行持久化时，Redis会fork一个子进程，子进程将数据写入临时文件中，当数据写入临时文件完成后，再替换旧的RDB文件。这个过程并不会阻塞主线程的工作，但在fork子进程时，如果数据量太大，可能会出现短暂的停顿。可以通过配置设置RDB的快照生成条件，比如每过一段时间或者数据更新达到一定数量的时候生成一次快照。
      - AOF (Append Only File) 持久化会将每一次写命令都记录下来，并追加到AOF文件的末尾.
        > 当Redis重启后，会通过重新执行AOF文件中的命令来恢复数据。AOF文件的持久化方式有三种：每次写命令后立即同步，每秒同步一次，或者由操作系统来决定何时同步。每次写命令后立即同步的方式最安全但性能最差，由操作系统来决定何时同步的方式性能最好但在宕机时可能会丢失部分写命令。如果RDB和AOF同时开启，当Redis重启时，会优先使用AOF来恢复数据，因为AOF提供的数据通常比RDB更完整。`**无论是RDB还是AOF，都只能保证在一定程度上的数据安全，并不能完全保证数据不丢失。**`
11.  
